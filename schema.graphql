type Query {
  viewer: User
  users: [User!]!
  tracks: [Track!]!
  trackSession(id: ID!): TrackSession!
  track(id: ID!): Track
  adminOrphanedMedia: [AdminOrphanedMedia!]!
  adminTempDirs: [AdminTempDir!]!
  adminRecordingHealth: [AdminRecordingHealth!]!
  adminRenderJobs: [AdminRenderJob!]!
  adminUserMediaLibraries: [AdminUserMediaLibrary!]!
  adminUsers: [AdminUser!]!
  adminTempCleanupSchedule: TempCleanupSchedule!
}

type AdminOrphanedMedia {
  mediaId: String!
  sizeBytes: Float!
  modifiedAt: String!
}

enum AdminTempDirName {
  UPLOADS
  RENDERS
  PREVIEWS
}

type AdminTempDir {
  name: AdminTempDirName!
  path: String!
  sizeBytes: Float!
  fileCount: Int!
}

type AdminRecordingHealth {
  status: TrackRecordingStatus!
  count: Int!
}

enum RenderJobType {
  COMBINE
  OVERLAY
}

type AdminRenderJob {
  recordingId: ID!
  sessionId: ID
  description: String
  userId: ID!
  username: String
  type: RenderJobType!
  progress: Float!
  startedAt: String!
}

type AdminUserMediaLibrary {
  userId: ID!
  username: String!
  sizeBytes: Float!
  recordingCount: Int!
}

type AdminUser {
  id: ID!
  username: String!
  createdAt: String!
  isAdmin: Boolean!
}

type CancelRenderJobPayload {
  success: Boolean!
}

type TempCleanupSchedule {
  hour: Int!
  days: [Int!]!
  enabled: Boolean!
  lastRunAt: String
  nextRunAt: String
}

input UpdateTempCleanupScheduleInput {
  hour: Int!
  days: [Int!]!
}

type UpdateTempCleanupSchedulePayload {
  schedule: TempCleanupSchedule!
}

type RunTempCleanupPayload {
  started: Boolean!
  schedule: TempCleanupSchedule!
}

input CreateTrackInput {
  name: String!
  heroImage: String
  karts: [CreateKartInput!]!
  trackLayouts: [CreateTrackLayoutInput!]!
}

type CreateTrackPayload {
  track: Track!
}

input LapInput {
  lapNumber: Int!
  time: Float!
  lapEvents: [LapEventInput!]
}

input LapEventInput {
  offset: Float!
  event: String!
  value: String!
}

input CreateTrackSessionInput {
  date: String!
  format: String!
  classification: Int!
  conditions: String
  trackId: ID
  kartId: ID!
  trackLayoutId: ID!
  notes: String
  laps: [LapInput!]
  fastestLap: Float
}

type CreateTrackSessionPayload {
  trackSession: TrackSession!
}

input UpdateTrackSessionInput {
  id: ID!
  date: String
  format: String
  classification: Int
  conditions: String
  trackId: ID
  kartId: ID
  trackLayoutId: ID
  notes: String
  fastestLap: Float
}

type UpdateTrackSessionPayload {
  trackSession: TrackSession!
}

input UpdateTrackSessionLapsInput {
  id: ID!
  laps: [LapInput!]!
}

type UpdateTrackSessionLapsPayload {
  trackSession: TrackSession!
}

input RecordingSourceInput {
  fileName: String!
  sizeBytes: Float
  trimStartMs: Float
  trimEndMs: Float
}

input StartTrackRecordingUploadInput {
  sessionId: ID!
  description: String
  lapOneOffset: Float
  sources: [RecordingSourceInput!]!
}

type StartTrackRecordingUploadPayload {
  recording: TrackRecording!
  uploadTargets: [RecordingUploadTarget!]!
}

type MarkPrimaryTrackRecordingPayload {
  recording: TrackRecording!
}

input UpdateTrackRecordingInput {
  id: ID!
  lapOneOffset: Float
  showInMediaLibrary: Boolean
}

enum OverlayTextColor {
  WHITE
  YELLOW
}

enum OverlayPosition {
  TOP_LEFT
  TOP_RIGHT
  BOTTOM_LEFT
  BOTTOM_RIGHT
}

enum OverlayExportQuality {
  BEST
  GOOD
  ULTRAFAST
}

enum OverlayExportCodec {
  H265
  H264
}

input OverlayStyleInput {
  textColor: OverlayTextColor
  textSize: Float
  detailTextSize: Float
  overlayPosition: OverlayPosition
  boxOpacity: Float
  showLapCounter: Boolean
  showPosition: Boolean
  showLapDeltas: Boolean
}

input RenderOverlayPreviewInput {
  recordingId: ID!
  lapId: ID!
  offsetSeconds: Float!
  style: OverlayStyleInput
}

input BurnRecordingOverlayInput {
  recordingId: ID!
  quality: OverlayExportQuality!
  codec: OverlayExportCodec = H265
  style: OverlayStyleInput
  embedChapters: Boolean = true
}

type UpdateTrackRecordingPayload {
  recording: TrackRecording!
}

type DeleteTrackRecordingPayload {
  success: Boolean!
}

type OverlayPreview {
  id: ID!
  recordingId: ID!
  lapId: ID!
  lapNumber: Int!
  previewUrl: String!
  requestedOffsetSeconds: Float!
  usedOffsetSeconds: Float!
  previewTimeSeconds: Float!
  generatedAt: String!
}

type RenderOverlayPreviewPayload {
  preview: OverlayPreview!
}

type DeleteTrackSessionPayload {
  success: Boolean!
}

type BurnRecordingOverlayPayload {
  recording: TrackRecording!
}

type Mutation {
  register(input: AuthInput!): AuthPayload!
  login(input: AuthInput!): AuthPayload!
  logout: LogoutResult!
  createTrack(input: CreateTrackInput!): CreateTrackPayload!
  createTrackSession(input: CreateTrackSessionInput!): CreateTrackSessionPayload!
  updateTrackSession(input: UpdateTrackSessionInput!): UpdateTrackSessionPayload!
  updateTrackSessionLaps(input: UpdateTrackSessionLapsInput!): UpdateTrackSessionLapsPayload!
  deleteTrackSession(id: ID!): DeleteTrackSessionPayload!
  startTrackRecordingUpload(
    input: StartTrackRecordingUploadInput!
  ): StartTrackRecordingUploadPayload!
  markPrimaryTrackRecording(id: ID!): MarkPrimaryTrackRecordingPayload!
  updateTrackRecording(input: UpdateTrackRecordingInput!): UpdateTrackRecordingPayload!
  renderOverlayPreview(input: RenderOverlayPreviewInput!): RenderOverlayPreviewPayload!
  burnRecordingOverlay(input: BurnRecordingOverlayInput!): BurnRecordingOverlayPayload!
  deleteTrackRecording(id: ID!): DeleteTrackRecordingPayload!
  createKart(input: CreateKartInput!): CreateKartPayload!
  updateKart(input: UpdateKartInput!): UpdateKartPayload!
  deleteKart(id: ID!): DeleteKartPayload!
  addKartToTrack(trackId: ID!, kartId: ID!): AddKartToTrackPayload!
  removeKartFromTrack(trackId: ID!, kartId: ID!): RemoveKartFromTrackPayload!
  addTrackLayoutToTrack(trackId: ID!, input: CreateTrackLayoutInput!): AddTrackLayoutToTrackPayload!
  updateTrackLayout(input: UpdateTrackLayoutInput!): UpdateTrackLayoutPayload!
  removeTrackLayoutFromTrack(trackId: ID!, trackLayoutId: ID!): RemoveTrackLayoutFromTrackPayload!
  updateTempCleanupSchedule(input: UpdateTempCleanupScheduleInput!): UpdateTempCleanupSchedulePayload!
  runTempCleanup: RunTempCleanupPayload!
  deleteOrphanedMedia(input: DeleteOrphanedMediaInput!): DeleteOrphanedMediaPayload!
  emptyTempDir(input: EmptyTempDirInput!): EmptyTempDirPayload!
  rebuildMediaLibraryProjectionAll: RebuildMediaLibraryProjectionAllPayload!
  updateUserAdminStatus(input: UpdateUserAdminStatusInput!): UpdateUserAdminStatusPayload!
  cancelRenderJob(recordingId: ID!): CancelRenderJobPayload!
}


input DeleteOrphanedMediaInput {
  mediaIds: [String!]!
}

type DeleteOrphanedMediaPayload {
  deleted: [String!]!
}

input EmptyTempDirInput {
  name: AdminTempDirName!
}

type EmptyTempDirPayload {
  name: AdminTempDirName!
}

type RebuildMediaLibraryProjectionAllPayload {
  rebuiltSessions: Int!
}

input UpdateUserAdminStatusInput {
  userId: ID!
  isAdmin: Boolean!
}

type UpdateUserAdminStatusPayload {
  user: AdminUser!
}

input AuthInput {
  username: String!
  password: String!
}

type User {
  id: ID!
  username: String!
  isAdmin: Boolean!
  createdAt: String!
  recentTracks(first: Int = 10, after: String): TrackConnection!
  recentTrackSessions(
    first: Int = 10
    after: String
    filter: TrackSessionFilterInput
    sort: TrackSessionSort = DATE_DESC
  ): TrackSessionConnection!
}

type Track {
  id: ID!
  name: String!
  heroImage: String
  timesRaced: Int!
  lastVisit: String
  sessionStats: TrackSessionStats!
  personalBestEntries: [TrackPersonalBest!]!
  karts: [Kart!]!
  trackLayouts: [TrackLayout!]!
}

type TrackSessionStats {
  totalSessions: Int!
  byKart: [TrackSessionKartStat!]!
  byTrackLayout: [TrackSessionLayoutStat!]!
  byCondition: [TrackSessionConditionStat!]!
}

type TrackSessionKartStat {
  kart: Kart
  count: Int!
}

type TrackSessionLayoutStat {
  trackLayout: TrackLayout!
  count: Int!
}

type TrackSessionConditionStat {
  conditions: String!
  count: Int!
}

type TrackPersonalBest {
  kart: Kart!
  trackLayout: TrackLayout!
  trackSessionId: ID!
  conditions: String!
  lapTime: Float!
}

type Kart {
  id: ID!
  name: String!
  createdAt: String!
  updatedAt: String!
}

type TrackLayout {
  id: ID!
  name: String!
  track: Track!
  createdAt: String!
  updatedAt: String!
}

type TrackEdge {
  cursor: String!
  node: Track!
}

type TrackConnection {
  edges: [TrackEdge!]!
  pageInfo: PageInfo!
}

type TrackSession {
  id: ID!
  date: String!
  format: String!
  classification: Int!
  fastestLap: Float
  conditions: String!
  track: Track!
  trackLayout: TrackLayout!
  kart: Kart
  consistencyScore: Int
  consistency: TrackSessionConsistency!
  notes: String
  createdAt: String!
  updatedAt: String!
  laps(first: Int = 10): [Lap!]!
  trackRecordings(first: Int = 10): [TrackRecording!]!
}

enum ConsistencyExclusionReason {
  INVALID
  OUT_LAP
  OUTLIER
}

type ConsistencyExcludedLap {
  lapNumber: Int!
  reason: ConsistencyExclusionReason!
}

type TrackSessionConsistency {
  score: Int
  label: String!
  mean: Float
  stdDev: Float
  cvPct: Float
  median: Float
  windowPct: Float
  cleanLapCount: Int!
  excludedLapCount: Int!
  totalValidLapCount: Int!
  usableLapNumbers: [Int!]!
  excludedLaps: [ConsistencyExcludedLap!]!
}

type Lap {
  id: ID!
  session: TrackSession!
  lapNumber: Int!
  time: Float!
  createdAt: String!
  updatedAt: String!
  lapEvents(first: Int = 10): [LapEvent!]!
  personalBest: Float
}

type TrackSessionEdge {
  cursor: String!
  node: TrackSession!
}

type TrackSessionConnection {
  edges: [TrackSessionEdge!]!
  pageInfo: PageInfo!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type LapEvent {
  id: ID!
  lap: Lap!
  offset: Float!
  event: String!
  value: String!
  createdAt: String!
  updatedAt: String!
}

input TrackSessionFilterInput {
  trackId: ID
  trackLayoutId: ID
  kartId: ID
  conditions: String
  format: String
}

enum TrackSessionSort {
  DATE_ASC
  DATE_DESC
  FASTEST_LAP_ASC
  FASTEST_LAP_DESC
  CONSISTENCY_ASC
  CONSISTENCY_DESC
}

enum TrackRecordingStatus {
  PENDING_UPLOAD
  UPLOADING
  COMBINING
  READY
  FAILED
}

enum RecordingUploadStatus {
  PENDING
  UPLOADING
  UPLOADED
  FAILED
}

type RecordingUploadTarget {
  id: ID!
  fileName: String!
  sizeBytes: Float
  uploadedBytes: Float!
  status: RecordingUploadStatus!
  ordinal: Int!
  uploadUrl: String
}

type RecordingUploadProgress {
  uploadedBytes: Float!
  totalBytes: Float
}

type TrackRecording {
  id: ID!
  session: TrackSession!
  mediaId: String!
  overlayBurned: Boolean!
  isPrimary: Boolean!
  showInMediaLibrary: Boolean!
  lapOneOffset: Float!
  description: String
  status: TrackRecordingStatus!
  error: String
  sizeBytes: Float
  durationMs: Float
  fps: Float
  combineProgress: Float
  uploadProgress: RecordingUploadProgress!
  uploadTargets(first: Int = 10): [RecordingUploadTarget!]!
  createdAt: String!
  updatedAt: String!
}

type AuthPayload {
  user: User!
  sessionExpiresAt: String!
}

type LogoutResult {
  success: Boolean!
}

input CreateKartInput {
  name: String!
}

input CreateTrackLayoutInput {
  name: String!
}

type CreateKartPayload {
  kart: Kart!
}

input UpdateKartInput {
  id: ID!
  name: String!
}

input UpdateTrackLayoutInput {
  id: ID!
  name: String!
}

type UpdateKartPayload {
  kart: Kart!
}

type UpdateTrackLayoutPayload {
  trackLayout: TrackLayout!
}

type DeleteKartPayload {
  success: Boolean!
}

type AddKartToTrackPayload {
  track: Track!
  kart: Kart!
}

type RemoveKartFromTrackPayload {
  track: Track!
  kart: Kart!
}

type AddTrackLayoutToTrackPayload {
  track: Track!
  trackLayout: TrackLayout!
}

type RemoveTrackLayoutFromTrackPayload {
  track: Track!
  trackLayout: TrackLayout!
}
