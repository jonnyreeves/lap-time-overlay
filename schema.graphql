type Query {
  viewer: User
  tracks: [Track!]!
  trackSession(id: ID!): TrackSession!
  track(id: ID!): Track
}

input CreateTrackInput {
  name: String!
  heroImage: String
  karts: [CreateKartInput!]!
  trackLayouts: [CreateTrackLayoutInput!]!
}

type CreateTrackPayload {
  track: Track!
}

input LapInput {
  lapNumber: Int!
  time: Float!
  lapEvents: [LapEventInput!]
}

input LapEventInput {
  offset: Float!
  event: String!
  value: String!
}

input CreateTrackSessionInput {
  date: String!
  format: String!
  classification: Int!
  conditions: String
  trackId: ID
  kartId: ID!
  trackLayoutId: ID!
  notes: String
  laps: [LapInput!]
  fastestLap: Float
}

type CreateTrackSessionPayload {
  trackSession: TrackSession!
}

input UpdateTrackSessionInput {
  id: ID!
  date: String
  format: String
  classification: Int
  conditions: String
  trackId: ID
  kartId: ID
  trackLayoutId: ID
  notes: String
  fastestLap: Float
}

type UpdateTrackSessionPayload {
  trackSession: TrackSession!
}

input UpdateTrackSessionLapsInput {
  id: ID!
  laps: [LapInput!]!
}

type UpdateTrackSessionLapsPayload {
  trackSession: TrackSession!
}

input RecordingSourceInput {
  fileName: String!
  sizeBytes: Float
}

input StartTrackRecordingUploadInput {
  sessionId: ID!
  description: String
  lapOneOffset: Float
  sources: [RecordingSourceInput!]!
}

type StartTrackRecordingUploadPayload {
  recording: TrackRecording!
  uploadTargets: [RecordingUploadTarget!]!
}

type MarkPrimaryTrackRecordingPayload {
  recording: TrackRecording!
}

input UpdateTrackRecordingInput {
  id: ID!
  lapOneOffset: Float!
}

type UpdateTrackRecordingPayload {
  recording: TrackRecording!
}

type DeleteTrackRecordingPayload {
  success: Boolean!
}

type Mutation {
  register(input: AuthInput!): AuthPayload!
  login(input: AuthInput!): AuthPayload!
  logout: LogoutResult!
  createTrack(input: CreateTrackInput!): CreateTrackPayload!
  createTrackSession(input: CreateTrackSessionInput!): CreateTrackSessionPayload!
  updateTrackSession(input: UpdateTrackSessionInput!): UpdateTrackSessionPayload!
  updateTrackSessionLaps(input: UpdateTrackSessionLapsInput!): UpdateTrackSessionLapsPayload!
  startTrackRecordingUpload(
    input: StartTrackRecordingUploadInput!
  ): StartTrackRecordingUploadPayload!
  markPrimaryTrackRecording(id: ID!): MarkPrimaryTrackRecordingPayload!
  updateTrackRecording(input: UpdateTrackRecordingInput!): UpdateTrackRecordingPayload!
  deleteTrackRecording(id: ID!): DeleteTrackRecordingPayload!
  createKart(input: CreateKartInput!): CreateKartPayload!
  updateKart(input: UpdateKartInput!): UpdateKartPayload!
  deleteKart(id: ID!): DeleteKartPayload!
  addKartToTrack(trackId: ID!, kartId: ID!): AddKartToTrackPayload!
  removeKartFromTrack(trackId: ID!, kartId: ID!): RemoveKartFromTrackPayload!
  addTrackLayoutToTrack(trackId: ID!, input: CreateTrackLayoutInput!): AddTrackLayoutToTrackPayload!
  updateTrackLayout(input: UpdateTrackLayoutInput!): UpdateTrackLayoutPayload!
  removeTrackLayoutFromTrack(trackId: ID!, trackLayoutId: ID!): RemoveTrackLayoutFromTrackPayload!
}

input AuthInput {
  username: String!
  password: String!
}

type User {
  id: ID!
  username: String!
  createdAt: String!
  recentTracks(first: Int = 10, after: String): TrackConnection!
  recentTrackSessions(
    first: Int = 10
    after: String
    filter: TrackSessionFilterInput
    sort: TrackSessionSort = DATE_DESC
  ): TrackSessionConnection!
}

type Track {
  id: ID!
  name: String!
  heroImage: String
  timesRaced: Int!
  lastVisit: String
  sessionStats: TrackSessionStats!
  personalBestEntries: [TrackPersonalBest!]!
  karts: [Kart!]!
  trackLayouts: [TrackLayout!]!
}

type TrackSessionStats {
  totalSessions: Int!
  byKart: [TrackSessionKartStat!]!
  byTrackLayout: [TrackSessionLayoutStat!]!
  byCondition: [TrackSessionConditionStat!]!
}

type TrackSessionKartStat {
  kart: Kart
  count: Int!
}

type TrackSessionLayoutStat {
  trackLayout: TrackLayout!
  count: Int!
}

type TrackSessionConditionStat {
  conditions: String!
  count: Int!
}

type TrackPersonalBest {
  kart: Kart!
  trackLayout: TrackLayout!
  trackSessionId: ID!
  conditions: String!
  lapTime: Float!
}

type Kart {
  id: ID!
  name: String!
  createdAt: String!
  updatedAt: String!
}

type TrackLayout {
  id: ID!
  name: String!
  track: Track!
  createdAt: String!
  updatedAt: String!
}

type TrackEdge {
  cursor: String!
  node: Track!
}

type TrackConnection {
  edges: [TrackEdge!]!
  pageInfo: PageInfo!
}

type TrackSession {
  id: ID!
  date: String!
  format: String!
  classification: Int!
  fastestLap: Float
  conditions: String!
  track: Track!
  trackLayout: TrackLayout!
  kart: Kart
  consistencyScore: Int
  consistency: TrackSessionConsistency!
  notes: String
  createdAt: String!
  updatedAt: String!
  laps(first: Int = 10): [Lap!]!
  trackRecordings(first: Int = 10): [TrackRecording!]!
}

enum ConsistencyExclusionReason {
  INVALID
  OUT_LAP
  OUTLIER
}

type ConsistencyExcludedLap {
  lapNumber: Int!
  reason: ConsistencyExclusionReason!
}

type TrackSessionConsistency {
  score: Int
  label: String!
  mean: Float
  stdDev: Float
  cvPct: Float
  median: Float
  windowPct: Float
  cleanLapCount: Int!
  excludedLapCount: Int!
  totalValidLapCount: Int!
  usableLapNumbers: [Int!]!
  excludedLaps: [ConsistencyExcludedLap!]!
}

type Lap {
  id: ID!
  session: TrackSession!
  lapNumber: Int!
  time: Float!
  createdAt: String!
  updatedAt: String!
  lapEvents(first: Int = 10): [LapEvent!]!
  personalBest: Float
}

type TrackSessionEdge {
  cursor: String!
  node: TrackSession!
}

type TrackSessionConnection {
  edges: [TrackSessionEdge!]!
  pageInfo: PageInfo!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type LapEvent {
  id: ID!
  lap: Lap!
  offset: Float!
  event: String!
  value: String!
  createdAt: String!
  updatedAt: String!
}

input TrackSessionFilterInput {
  trackId: ID
  trackLayoutId: ID
  kartId: ID
  conditions: String
  format: String
}

enum TrackSessionSort {
  DATE_ASC
  DATE_DESC
  FASTEST_LAP_ASC
  FASTEST_LAP_DESC
  CONSISTENCY_ASC
  CONSISTENCY_DESC
}

enum TrackRecordingStatus {
  PENDING_UPLOAD
  UPLOADING
  COMBINING
  READY
  FAILED
}

enum RecordingUploadStatus {
  PENDING
  UPLOADING
  UPLOADED
  FAILED
}

type RecordingUploadTarget {
  id: ID!
  fileName: String!
  sizeBytes: Float
  uploadedBytes: Float!
  status: RecordingUploadStatus!
  ordinal: Int!
  uploadUrl: String
}

type RecordingUploadProgress {
  uploadedBytes: Float!
  totalBytes: Float
}

type TrackRecording {
  id: ID!
  session: TrackSession!
  mediaId: String!
  isPrimary: Boolean!
  lapOneOffset: Float!
  description: String
  status: TrackRecordingStatus!
  error: String
  sizeBytes: Float
  durationMs: Float
  fps: Float
  combineProgress: Float
  uploadProgress: RecordingUploadProgress!
  uploadTargets(first: Int = 10): [RecordingUploadTarget!]!
  createdAt: String!
  updatedAt: String!
}

type AuthPayload {
  user: User!
  sessionExpiresAt: String!
}

type LogoutResult {
  success: Boolean!
}

input CreateKartInput {
  name: String!
}

input CreateTrackLayoutInput {
  name: String!
}

type CreateKartPayload {
  kart: Kart!
}

input UpdateKartInput {
  id: ID!
  name: String!
}

input UpdateTrackLayoutInput {
  id: ID!
  name: String!
}

type UpdateKartPayload {
  kart: Kart!
}

type UpdateTrackLayoutPayload {
  trackLayout: TrackLayout!
}

type DeleteKartPayload {
  success: Boolean!
}

type AddKartToTrackPayload {
  track: Track!
  kart: Kart!
}

type RemoveKartFromTrackPayload {
  track: Track!
  kart: Kart!
}

type AddTrackLayoutToTrackPayload {
  track: Track!
  trackLayout: TrackLayout!
}

type RemoveTrackLayoutFromTrackPayload {
  track: Track!
  trackLayout: TrackLayout!
}
