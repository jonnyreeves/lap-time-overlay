type Query {
  viewer: User
  circuits: [Circuit!]!
  trackSession(id: ID!): TrackSession!
  circuit(id: ID!): Circuit
}

input CreateCircuitInput {
  name: String!
  heroImage: String
}

type CreateCircuitPayload {
  circuit: Circuit!
}

input LapInput {
  lapNumber: Int!
  time: Float!
  lapEvents: [LapEventInput!]
}

input LapEventInput {
  offset: Float!
  event: String!
  value: String!
}

input CreateTrackSessionInput {
  date: String!
  format: String!
  classification: Int!
  conditions: String
  circuitId: ID!
  notes: String
  laps: [LapInput!]
}

type CreateTrackSessionPayload {
  trackSession: TrackSession!
}

input UpdateTrackSessionInput {
  id: ID!
  date: String
  format: String
  classification: Int
  conditions: String
  circuitId: ID
  notes: String
}

type UpdateTrackSessionPayload {
  trackSession: TrackSession!
}

input UpdateTrackSessionLapsInput {
  id: ID!
  laps: [LapInput!]!
}

type UpdateTrackSessionLapsPayload {
  trackSession: TrackSession!
}

input RecordingSourceInput {
  fileName: String!
  sizeBytes: Float
}

input StartTrackRecordingUploadInput {
  sessionId: ID!
  description: String
  lapOneOffset: Float
  sources: [RecordingSourceInput!]!
}

type StartTrackRecordingUploadPayload {
  recording: TrackRecording!
  uploadTargets: [RecordingUploadTarget!]!
}

type MarkPrimaryTrackRecordingPayload {
  recording: TrackRecording!
}

input UpdateTrackRecordingInput {
  id: ID!
  lapOneOffset: Float!
}

type UpdateTrackRecordingPayload {
  recording: TrackRecording!
}

type DeleteTrackRecordingPayload {
  success: Boolean!
}

type Mutation {
  register(input: AuthInput!): AuthPayload!
  login(input: AuthInput!): AuthPayload!
  logout: LogoutResult!
  createCircuit(input: CreateCircuitInput!): CreateCircuitPayload!
  createTrackSession(input: CreateTrackSessionInput!): CreateTrackSessionPayload!
  updateTrackSession(input: UpdateTrackSessionInput!): UpdateTrackSessionPayload!
  updateTrackSessionLaps(input: UpdateTrackSessionLapsInput!): UpdateTrackSessionLapsPayload!
  startTrackRecordingUpload(
    input: StartTrackRecordingUploadInput!
  ): StartTrackRecordingUploadPayload!
  markPrimaryTrackRecording(id: ID!): MarkPrimaryTrackRecordingPayload!
  updateTrackRecording(input: UpdateTrackRecordingInput!): UpdateTrackRecordingPayload!
  deleteTrackRecording(id: ID!): DeleteTrackRecordingPayload!
}

input AuthInput {
  username: String!
  password: String!
}

type User {
  id: ID!
  username: String!
  createdAt: String!
  recentCircuits(first: Int = 10, after: String): CircuitConnection!
  recentTrackSessions(first: Int = 10, after: String): TrackSessionConnection!
}

type Circuit {
  id: ID!
  name: String!
  heroImage: String
  personalBest: Float
  personalBestDry: Float
  personalBestWet: Float
}

type CircuitEdge {
  cursor: String!
  node: Circuit!
}

type CircuitConnection {
  edges: [CircuitEdge!]!
  pageInfo: PageInfo!
}

type TrackSession {
  id: ID!
  date: String!
  format: String!
  classification: Int!
  conditions: String!
  circuit: Circuit!
  notes: String
  createdAt: String!
  updatedAt: String!
  laps(first: Int = 10): [Lap!]!
  trackRecordings(first: Int = 10): [TrackRecording!]!
}

type Lap {
  id: ID!
  session: TrackSession!
  lapNumber: Int!
  time: Float!
  createdAt: String!
  updatedAt: String!
  lapEvents(first: Int = 10): [LapEvent!]!
  personalBest: Float
}

type TrackSessionEdge {
  cursor: String!
  node: TrackSession!
}

type TrackSessionConnection {
  edges: [TrackSessionEdge!]!
  pageInfo: PageInfo!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type LapEvent {
  id: ID!
  lap: Lap!
  offset: Float!
  event: String!
  value: String!
  createdAt: String!
  updatedAt: String!
}

enum TrackRecordingStatus {
  PENDING_UPLOAD
  UPLOADING
  COMBINING
  READY
  FAILED
}

enum RecordingUploadStatus {
  PENDING
  UPLOADING
  UPLOADED
  FAILED
}

type RecordingUploadTarget {
  id: ID!
  fileName: String!
  sizeBytes: Float
  uploadedBytes: Float!
  status: RecordingUploadStatus!
  ordinal: Int!
  uploadUrl: String
}

type RecordingUploadProgress {
  uploadedBytes: Float!
  totalBytes: Float
}

type TrackRecording {
  id: ID!
  session: TrackSession!
  mediaId: String!
  isPrimary: Boolean!
  lapOneOffset: Float!
  description: String
  status: TrackRecordingStatus!
  error: String
  sizeBytes: Float
  durationMs: Float
  fps: Float
  combineProgress: Float
  uploadProgress: RecordingUploadProgress!
  uploadTargets(first: Int = 10): [RecordingUploadTarget!]!
  createdAt: String!
  updatedAt: String!
}

type AuthPayload {
  user: User!
  sessionExpiresAt: String!
}

type LogoutResult {
  success: Boolean!
}
